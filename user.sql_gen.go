// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: user.sql

package nakama

import (
	"context"
	"time"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, username)
VALUES ($1, LOWER($2), $3)
RETURNING created_at
`

type CreateUserParams struct {
	UserID   string
	Email    string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.UserID, arg.Email, arg.Username)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    posts_count = posts_count + $1,
    followers_count = followers_count + $2,
    following_count = following_count + $3,
    updated_at = now()
WHERE id = $4
RETURNING updated_at
`

type UpdateUserParams struct {
	IncreasePostsCountBy     int32
	IncreaseFollowersCountBy int32
	IncreaseFollowingCountBy int32
	UserID                   string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.IncreasePostsCountBy,
		arg.IncreaseFollowersCountBy,
		arg.IncreaseFollowingCountBy,
		arg.UserID,
	)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const user = `-- name: User :one
SELECT users.id, users.email, users.username, users.posts_count, users.followers_count, users.following_count, users.created_at, users.updated_at,
(
    CASE
        WHEN $1::varchar != '' THEN (
            SELECT EXISTS (
                SELECT 1 FROM user_follows
                WHERE follower_id = $1::varchar
                AND followed_id = users.id
            )
        )
        ELSE false
    END
) AS following
FROM users
WHERE CASE
    WHEN $2::varchar != '' THEN users.id = $2::varchar
    WHEN $3::varchar != '' THEN users.email = LOWER($3::varchar)
    WHEN $4::varchar != '' THEN LOWER(users.username) = LOWER($4::varchar)
    ELSE false
END
`

type UserParams struct {
	FollowerID string
	UserID     string
	Email      string
	Username   string
}

type UserRow struct {
	ID             string
	Email          string
	Username       string
	PostsCount     int32
	FollowersCount int32
	FollowingCount int32
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Following      bool
}

func (q *Queries) User(ctx context.Context, arg UserParams) (UserRow, error) {
	row := q.db.QueryRowContext(ctx, user,
		arg.FollowerID,
		arg.UserID,
		arg.Email,
		arg.Username,
	)
	var i UserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PostsCount,
		&i.FollowersCount,
		&i.FollowingCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Following,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS (
    SELECT 1 FROM users WHERE CASE
        WHEN $1::varchar != '' THEN id = $1::varchar
        WHEN $2::varchar != '' THEN email = LOWER($2::varchar)
        WHEN $3::varchar != '' THEN LOWER(username) = LOWER($3::varchar)
        ELSE false
    END
)
`

type UserExistsParams struct {
	UserID   string
	Email    string
	Username string
}

func (q *Queries) UserExists(ctx context.Context, arg UserExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, arg.UserID, arg.Email, arg.Username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
