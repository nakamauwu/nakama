// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package nakama

import (
	"context"
	"time"
)

const comments = `-- name: Comments :many
SELECT comments.id, comments.user_id, comments.post_id, comments.content, comments.created_at, comments.updated_at, users.username
FROM comments
INNER JOIN users ON comments.user_id = users.id
WHERE comments.post_id = $1
ORDER BY comments.id DESC
`

type CommentsRow struct {
	ID        string
	UserID    string
	PostID    string
	Content   string
	CreatedAt time.Time
	UpdatedAt time.Time
	Username  string
}

func (q *Queries) Comments(ctx context.Context, postID string) ([]CommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, comments, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommentsRow
	for rows.Next() {
		var i CommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (id, user_id, post_id, content)
VALUES ($1, $2, $3, $4)
RETURNING created_at
`

type CreateCommentParams struct {
	CommentID string
	UserID    string
	PostID    string
	Content   string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.CommentID,
		arg.UserID,
		arg.PostID,
		arg.Content,
	)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const createHomeTimelineItem = `-- name: CreateHomeTimelineItem :one
INSERT INTO home_timeline (user_id, post_id)
VALUES ($1, $2)
RETURNING id, created_at
`

type CreateHomeTimelineItemParams struct {
	UserID string
	PostID string
}

type CreateHomeTimelineItemRow struct {
	ID        string
	CreatedAt time.Time
}

func (q *Queries) CreateHomeTimelineItem(ctx context.Context, arg CreateHomeTimelineItemParams) (CreateHomeTimelineItemRow, error) {
	row := q.db.QueryRowContext(ctx, createHomeTimelineItem, arg.UserID, arg.PostID)
	var i CreateHomeTimelineItemRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (id, user_id, content)
VALUES ($1, $2, $3)
RETURNING created_at
`

type CreatePostParams struct {
	PostID  string
	UserID  string
	Content string
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createPost, arg.PostID, arg.UserID, arg.Content)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, username)
VALUES ($1, LOWER($2), $3)
RETURNING created_at
`

type CreateUserParams struct {
	UserID   string
	Email    string
	Username string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.UserID, arg.Email, arg.Username)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const createUserFollow = `-- name: CreateUserFollow :one
INSERT INTO user_follows (follower_id, followed_id)
VALUES ($1, $2)
RETURNING created_at
`

type CreateUserFollowParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) CreateUserFollow(ctx context.Context, arg CreateUserFollowParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createUserFollow, arg.FollowerID, arg.FollowedID)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const deleteUserFollow = `-- name: DeleteUserFollow :one
DELETE FROM user_follows
WHERE follower_id = $1
AND followed_id = $2
RETURNING now()::timestamp AS deleted_at
`

type DeleteUserFollowParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) DeleteUserFollow(ctx context.Context, arg DeleteUserFollowParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, deleteUserFollow, arg.FollowerID, arg.FollowedID)
	var deleted_at time.Time
	err := row.Scan(&deleted_at)
	return deleted_at, err
}

const fanoutHomeTimeline = `-- name: FanoutHomeTimeline :many
INSERT INTO home_timeline (user_id, post_id)
SELECT user_follows.follower_id, $1
FROM user_follows
WHERE user_follows.followed_id = $2
ON CONFLICT (user_id, post_id) DO NOTHING
RETURNING id, created_at
`

type FanoutHomeTimelineParams struct {
	PostsID    string
	FollowedID string
}

type FanoutHomeTimelineRow struct {
	ID        string
	CreatedAt time.Time
}

func (q *Queries) FanoutHomeTimeline(ctx context.Context, arg FanoutHomeTimelineParams) ([]FanoutHomeTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, fanoutHomeTimeline, arg.PostsID, arg.FollowedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FanoutHomeTimelineRow
	for rows.Next() {
		var i FanoutHomeTimelineRow
		if err := rows.Scan(&i.ID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const homeTimeline = `-- name: HomeTimeline :many
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM home_timeline
INNER JOIN posts ON home_timeline.post_id = posts.id
INNER JOIN users ON posts.user_id = users.id
WHERE home_timeline.user_id = $1
ORDER BY home_timeline.id DESC
`

type HomeTimelineRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) HomeTimeline(ctx context.Context, userID string) ([]HomeTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, homeTimeline, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HomeTimelineRow
	for rows.Next() {
		var i HomeTimelineRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const post = `-- name: Post :one
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM posts
INNER JOIN users ON posts.user_id = users.id
WHERE posts.id = $1
`

type PostRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) Post(ctx context.Context, postID string) (PostRow, error) {
	row := q.db.QueryRowContext(ctx, post, postID)
	var i PostRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.CommentsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
	)
	return i, err
}

const posts = `-- name: Posts :many
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM posts
INNER JOIN users ON posts.user_id = users.id
WHERE
    CASE
        WHEN $1::varchar <> '' THEN LOWER(users.username) = LOWER($1::varchar)
        ELSE true
    END
ORDER BY posts.id DESC
`

type PostsRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) Posts(ctx context.Context, username string) ([]PostsRow, error) {
	rows, err := q.db.QueryContext(ctx, posts, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostsRow
	for rows.Next() {
		var i PostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET comments_count = comments_count + $1, updated_at = now()
WHERE id = $2
RETURNING updated_at
`

type UpdatePostParams struct {
	IncreaseCommentsCountBy int32
	PostID                  string
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updatePost, arg.IncreaseCommentsCountBy, arg.PostID)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    posts_count = posts_count + $1,
    followers_count = followers_count + $2,
    following_count = following_count + $3,
    updated_at = now()
WHERE id = $4
RETURNING updated_at
`

type UpdateUserParams struct {
	IncreasePostsCountBy     int32
	IncreaseFollowersCountBy int32
	IncreaseFollowingCountBy int32
	UserID                   string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.IncreasePostsCountBy,
		arg.IncreaseFollowersCountBy,
		arg.IncreaseFollowingCountBy,
		arg.UserID,
	)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT id, email, username, posts_count, followers_count, following_count, created_at, updated_at FROM users WHERE email = LOWER($1)
`

func (q *Queries) UserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PostsCount,
		&i.FollowersCount,
		&i.FollowingCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT users.id, users.email, users.username, users.posts_count, users.followers_count, users.following_count, users.created_at, users.updated_at,
(
    CASE
        WHEN $1::varchar <> '' THEN (
            SELECT EXISTS (
                SELECT 1 FROM user_follows
                WHERE follower_id = $1::varchar
                AND followed_id = users.id
            )
        )
        ELSE false
    END
) AS following
FROM users
WHERE LOWER(username) = LOWER($2)
`

type UserByUsernameParams struct {
	FollowerID string
	Username   string
}

type UserByUsernameRow struct {
	ID             string
	Email          string
	Username       string
	PostsCount     int32
	FollowersCount int32
	FollowingCount int32
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Following      bool
}

func (q *Queries) UserByUsername(ctx context.Context, arg UserByUsernameParams) (UserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, userByUsername, arg.FollowerID, arg.Username)
	var i UserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.PostsCount,
		&i.FollowersCount,
		&i.FollowingCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Following,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS (
    SELECT 1 FROM users WHERE id = $1
)
`

func (q *Queries) UserExists(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByEmail = `-- name: UserExistsByEmail :one
SELECT EXISTS (
    SELECT 1 FROM users WHERE email = LOWER($1)
)
`

func (q *Queries) UserExistsByEmail(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsByEmail, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userExistsByUsername = `-- name: UserExistsByUsername :one
SELECT EXISTS (
    SELECT 1 FROM users WHERE LOWER(username) = LOWER($1)
)
`

func (q *Queries) UserExistsByUsername(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExistsByUsername, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userFollowExists = `-- name: UserFollowExists :one
SELECT EXISTS (
    SELECT 1 FROM user_follows
    WHERE follower_id = $1
    AND followed_id = $2
)
`

type UserFollowExistsParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) UserFollowExists(ctx context.Context, arg UserFollowExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, userFollowExists, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
