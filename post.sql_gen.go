// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: post.sql

package nakama

import (
	"context"
	"time"
)

const createHomeTimelineItem = `-- name: CreateHomeTimelineItem :one
INSERT INTO home_timeline (user_id, post_id)
VALUES ($1, $2)
RETURNING id, created_at
`

type CreateHomeTimelineItemParams struct {
	UserID string
	PostID string
}

type CreateHomeTimelineItemRow struct {
	ID        string
	CreatedAt time.Time
}

func (q *Queries) CreateHomeTimelineItem(ctx context.Context, arg CreateHomeTimelineItemParams) (CreateHomeTimelineItemRow, error) {
	row := q.db.QueryRowContext(ctx, createHomeTimelineItem, arg.UserID, arg.PostID)
	var i CreateHomeTimelineItemRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (id, user_id, content)
VALUES ($1, $2, $3)
RETURNING created_at
`

type CreatePostParams struct {
	PostID  string
	UserID  string
	Content string
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createPost, arg.PostID, arg.UserID, arg.Content)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const fanoutHomeTimeline = `-- name: FanoutHomeTimeline :many
INSERT INTO home_timeline (user_id, post_id)
SELECT user_follows.follower_id, $1
FROM user_follows
WHERE user_follows.followed_id = $2
ON CONFLICT (user_id, post_id) DO NOTHING
RETURNING id, created_at
`

type FanoutHomeTimelineParams struct {
	PostsID    string
	FollowedID string
}

type FanoutHomeTimelineRow struct {
	ID        string
	CreatedAt time.Time
}

func (q *Queries) FanoutHomeTimeline(ctx context.Context, arg FanoutHomeTimelineParams) ([]FanoutHomeTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, fanoutHomeTimeline, arg.PostsID, arg.FollowedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FanoutHomeTimelineRow
	for rows.Next() {
		var i FanoutHomeTimelineRow
		if err := rows.Scan(&i.ID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const homeTimeline = `-- name: HomeTimeline :many
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM home_timeline
INNER JOIN posts ON home_timeline.post_id = posts.id
INNER JOIN users ON posts.user_id = users.id
WHERE home_timeline.user_id = $1
ORDER BY home_timeline.id DESC
`

type HomeTimelineRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) HomeTimeline(ctx context.Context, userID string) ([]HomeTimelineRow, error) {
	rows, err := q.db.QueryContext(ctx, homeTimeline, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HomeTimelineRow
	for rows.Next() {
		var i HomeTimelineRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const post = `-- name: Post :one
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM posts
INNER JOIN users ON posts.user_id = users.id
WHERE posts.id = $1
`

type PostRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) Post(ctx context.Context, postID string) (PostRow, error) {
	row := q.db.QueryRowContext(ctx, post, postID)
	var i PostRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.CommentsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
	)
	return i, err
}

const posts = `-- name: Posts :many
SELECT posts.id, posts.user_id, posts.content, posts.comments_count, posts.created_at, posts.updated_at, users.username
FROM posts
INNER JOIN users ON posts.user_id = users.id
WHERE
    CASE
        WHEN $1::varchar != '' THEN LOWER(users.username) = LOWER($1::varchar)
        ELSE true
    END
ORDER BY posts.id DESC
`

type PostsRow struct {
	ID            string
	UserID        string
	Content       string
	CommentsCount int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Username      string
}

func (q *Queries) Posts(ctx context.Context, username string) ([]PostsRow, error) {
	rows, err := q.db.QueryContext(ctx, posts, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostsRow
	for rows.Next() {
		var i PostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.CommentsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET comments_count = comments_count + $1, updated_at = now()
WHERE id = $2
RETURNING updated_at
`

type UpdatePostParams struct {
	IncreaseCommentsCountBy int32
	PostID                  string
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updatePost, arg.IncreaseCommentsCountBy, arg.PostID)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}
