package nakama

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5"
)

func (s *Store) CreatePost(ctx context.Context, in CreatePost) (Created, error) {
	var out Created

	const query = `
		INSERT INTO posts (id, user_id, content, media)
		VALUES ($1, $2, $3, $4)
		RETURNING created_at
	`
	postID := genID()
	row := s.db.QueryRow(ctx, query, postID, in.userID, in.Content, in.Media)
	err := row.Scan(&out.CreatedAt)
	if err != nil {
		return out, fmt.Errorf("sql scan inserted post: %w", err)
	}

	out.ID = postID

	return out, nil
}

func (s *Store) CreateTimelineItem(ctx context.Context, in CreateTimelineItem) (string, error) {
	const query = `
		INSERT INTO timeline (user_id, post_id)
		VALUES ($1, $2)
		RETURNING id
	`
	var id string
	row := s.db.QueryRow(ctx, query, in.userID, in.postID)
	err := row.Scan(&id)
	if err != nil {
		return "", fmt.Errorf("sql insert timeline item: %w", err)
	}

	return id, nil
}

func (s *Store) CreateTimeline(ctx context.Context, in CreateTimeline) ([]CreatedTimelineItem, error) {
	const query = `
		INSERT INTO timeline (user_id, post_id)
		SELECT user_follows.follower_id, $1
		FROM user_follows
		WHERE user_follows.followed_id = $2
		ON CONFLICT (user_id, post_id) DO NOTHING
		-- timeline id is autogenerated by the database using ulid.
		RETURNING id, user_id
	`

	rows, err := s.db.Query(ctx, query, in.postID, in.followedID)
	if err != nil {
		return nil, fmt.Errorf("sql fanout timeline: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (CreatedTimelineItem, error) {
		var out CreatedTimelineItem
		if err := row.Scan(&out.ID, &out.UserID); err != nil {
			return out, fmt.Errorf("sql scan fanout timeline: %w", err)
		}

		return out, nil
	})
}

func (s *Store) Posts(ctx context.Context, in ListPosts) ([]Post, error) {
	const query = `
		SELECT
			  posts.id
			, posts.user_id
			, posts.content
			, posts.media
			, posts.reactions_count
			, post_reactions.reactions
			, posts.comments_count
			, posts.created_at
			, posts.updated_at
			, users.username
			, users.avatar_path
			, users.avatar_width
			, users.avatar_height
		FROM posts
		INNER JOIN users ON posts.user_id = users.id
		LEFT JOIN (
			SELECT post_id, array_agg(reaction) AS reactions
			FROM post_reactions
			WHERE post_reactions.user_id = $1
			GROUP BY post_id
		) AS post_reactions ON post_reactions.post_id = posts.id
		WHERE
			CASE
				WHEN $2::varchar != '' THEN LOWER(users.username) = LOWER($2::varchar)
				ELSE true
			END
		ORDER BY posts.id DESC
	`
	rows, err := s.db.Query(ctx, query, in.authUserID, in.Username)
	if err != nil {
		return nil, fmt.Errorf("sql select posts: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (Post, error) {
		var out Post
		var reactions []string
		err := row.Scan(
			&out.ID,
			&out.UserID,
			&out.Content,
			&out.Media,
			&out.ReactionsCount,
			&reactions,
			&out.CommentsCount,
			&out.CreatedAt,
			&out.UpdatedAt,
			&out.User.Username,
			&out.User.AvatarPath,
			&out.User.AvatarWidth,
			&out.User.AvatarHeight,
		)
		if err != nil {
			return out, fmt.Errorf("sql scan posts: %w", err)
		}

		s.applyMediaPrefix(&out.Media)
		out.ReactionsCount.Apply(reactions)
		s.applyAvatarPrefix(&out.User.AvatarPath)

		return out, nil
	})
}

func (s *Store) Timeline(ctx context.Context, userID string) ([]Post, error) {
	const query = `
		SELECT
			  posts.id
			, posts.user_id
			, posts.content
			, posts.media
			, posts.reactions_count
			, post_reactions.reactions
			, posts.comments_count
			, posts.created_at
			, posts.updated_at
			, users.username
			, users.avatar_path
			, users.avatar_width
			, users.avatar_height
		FROM timeline
		INNER JOIN posts ON timeline.post_id = posts.id
		INNER JOIN users ON posts.user_id = users.id
		LEFT JOIN (
			SELECT post_id, array_agg(reaction) AS reactions
			FROM post_reactions
			WHERE post_reactions.user_id = $1
			GROUP BY post_id
		) AS post_reactions ON post_reactions.post_id = posts.id
		WHERE timeline.user_id = $1
		ORDER BY timeline.id DESC
	`
	rows, err := s.db.Query(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("sql select timeline: %w", err)
	}

	return pgx.CollectRows(rows, func(row pgx.CollectableRow) (Post, error) {
		var out Post
		var reactions []string
		err := row.Scan(
			&out.ID,
			&out.UserID,
			&out.Content,
			&out.Media,
			&out.ReactionsCount,
			&reactions,
			&out.CommentsCount,
			&out.CreatedAt,
			&out.UpdatedAt,
			&out.User.Username,
			&out.User.AvatarPath,
			&out.User.AvatarWidth,
			&out.User.AvatarHeight,
		)
		if err != nil {
			return out, fmt.Errorf("sql scan timeline items: %w", err)
		}

		s.applyMediaPrefix(&out.Media)
		out.ReactionsCount.Apply(reactions)
		s.applyAvatarPrefix(&out.User.AvatarPath)

		return out, nil
	})
}

func (s *Store) Post(ctx context.Context, in RetrievePost) (Post, error) {
	const query = `
		SELECT
			  posts.id
			, posts.user_id
			, posts.content
			, posts.media
			, posts.reactions_count
			, post_reactions.reactions
			, posts.comments_count
			, posts.created_at
			, posts.updated_at
			, users.username
			, users.avatar_path
			, users.avatar_width
			, users.avatar_height
		FROM posts
		INNER JOIN users ON posts.user_id = users.id
		LEFT JOIN (
			SELECT array_agg(reaction) AS reactions
			FROM post_reactions
			WHERE post_reactions.user_id = $1
				AND post_reactions.post_id = $2
		) AS post_reactions ON true
		WHERE posts.id = $2
	`
	var p Post
	var reactions []string
	err := s.db.QueryRow(ctx, query, in.authUserID, in.ID).Scan(
		&p.ID,
		&p.UserID,
		&p.Content,
		&p.Media,
		&p.ReactionsCount,
		&reactions,
		&p.CommentsCount,
		&p.CreatedAt,
		&p.UpdatedAt,
		&p.User.Username,
		&p.User.AvatarPath,
		&p.User.AvatarWidth,
		&p.User.AvatarHeight,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		return Post{}, ErrPostNotFound
	}

	if err != nil {
		return Post{}, fmt.Errorf("sql scan selected post: %w", err)
	}

	s.applyMediaPrefix(&p.Media)
	p.ReactionsCount.Apply(reactions)
	s.applyAvatarPrefix(&p.User.AvatarPath)

	return p, nil
}

func (s *Store) PostReactionsCount(ctx context.Context, postID string) (ReactionsCount, error) {
	const query = `
		SELECT reactions_count FROM posts WHERE id = $1
	`

	var out ReactionsCount
	row := s.db.QueryRow(ctx, query, postID)
	err := row.Scan(&out)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrPostNotFound
	}

	if err != nil {
		return nil, fmt.Errorf("sql scan selected post reactions count: %w", err)
	}

	return out, nil
}

func (s *Store) UpdatePost(ctx context.Context, in UpdatePost) (time.Time, error) {
	const query = `
		UPDATE posts
		SET comments_count = comments_count + $1
			, reactions_count = COALESCE($2, reactions_count)
			, updated_at = now()
		WHERE id = $3
		RETURNING updated_at
	`
	var updatedAt time.Time
	row := s.db.QueryRow(ctx, query,
		in.IncreaseCommentsCountBy,
		in.ReactionsCount,
		in.PostID,
	)
	err := row.Scan(&updatedAt)
	if err != nil {
		return time.Time{}, fmt.Errorf("sql scan updated post: %w", err)
	}

	return updatedAt, nil
}
